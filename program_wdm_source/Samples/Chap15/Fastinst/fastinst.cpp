// fastinst.cpp : Defines the class behaviors for the application.
// Copyright (C) 1999 by Walter Oney
// All rights reserved

#include "stdafx.h"
#include "setup.h"
#include "resource.h"
#include "ProgressDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

BOOL DeviceCallback(CInf* inf, const CString& devname, const CString& instsecname, const CStringArray& devid, PVOID context, DWORD& code);
BOOL MfgCallback(CInf* inf, const CString& mfgname, const CString& modelname, PVOID context, DWORD& code);
void ReportError(LPCTSTR fcn, DWORD code);

CProgressDlg* pprogress = NULL;

///////////////////////////////////////////////////////////////////////////////

class CFastInst : public CWinApp
{								// class CFastInst
public:
	virtual BOOL InitInstance();
};								// class CFastInst

CFastInst theApp;

BOOL CFastInst::InitInstance()
	{							// CFastInst::InitInstance
	if (__argc < 2 || __targv[1][0] == _T('?')
		|| (__targv[1][0] == _T('-') || __targv[1][0] == _T('/'))
		&& tolower(__targv[1][1]) == _T('h'))
		{						// display usage
		AfxMessageBox(_T("Usage is: FASTINST infname [devid]"));
		return FALSE;
		}						// display usage
	
	DWORD code;

	// Open the specifid INF file

	CInf inf;
	code = inf.Open(__targv[1], FALSE);
	if (code != 0)
		{
		ReportError(_T("SetupOpenInfFile"), code);
		return FALSE;
		}

	// Locate the model statement for the designated device, or for the first device
	// in the file.

	InstallStruct is;
	is.done = FALSE;
	if (__argc >= 3)
		is.devid = __targv[2];

	code = inf.EnumManufacturers(MfgCallback, (PVOID) &is);
	if (code != 0)
		{
		ReportError(_T("search for specified device"), code);
		return FALSE;
		}

	// Create a modeless progress dialog just to reassure the user that something is actually
	// happening. (Installs can take a while even using this module)

	CProgressDlg progress;
	progress.m_legend.Format(IDS_LEGEND, (LPCTSTR) is.devname, (LPCTSTR) inf.m_name);
	progress.Create(CProgressDlg::IDD, NULL);
	progress.ShowWindow(SW_SHOW);

	pprogress = &progress;

	// Create an empty device info set to act as a container for the one device
	// information element we'll create

	CDevInfoSet infoset;
	code = infoset.Create(&inf, NULL);
	if (code != 0)
		{
		ReportError(_T("SetupDiCreateDeviceInfoList"), code);
		return FALSE;
		}

	// Create a device info element. This step creates the hardware key in the
	// registry and sets the designated hardware id. The way we call
	// SetupDiCreateDeviceInfo, the key will be a subkey of the class key and
	// have an autogenerated name. (Note that the DDK doc is wrong when it says
	// you supply a device identifier for the name parameter.)

	code = infoset.CreateDeviceInfo(is.devid);
	if (code != 0)
		{
		ReportError(_T("SetupDiCreateDeviceInfo or SetupDiSetDeviceRegistryProperty"), code);
		return FALSE;
		}

	// Register the device with PnP. This step creates a DEVNODE, but there's still
	// no driver associated with the device at this point

	code = infoset.RegisterDevice();
	if (code != 0)
		{
		ReportError(_T("SetupDiCallClassInstaller(DIF_REGISTERDEVICE)"), code);
		return FALSE;
		}

	// Finally, install the driver

	code = infoset.UpdateDriver();
	if (code != 0)
		{
		ReportError(_T("UpdateDriverForPlugAndPlayDevices"), code);
		return FALSE;
		}

	progress.ShowWindow(SW_HIDE);

	return FALSE;
	}							// CFastInst::InitInstance

///////////////////////////////////////////////////////////////////////////////

BOOL DeviceCallback(CInf* inf, const CString& devname, const CString& instsecname, const CStringArray& devid, PVOID context, DWORD& code)
	{
	InstallStruct* isp = (InstallStruct*) context;
	int n = devid.GetSize();
	for (int i = 0; i < n; ++i)
		if (isp->devid == devid[i] || isp->devid.GetLength() == 0)
			break;

	if (i >= n)
		return TRUE;			// keep enumerating -- this isn't it

	isp->devid = devid[i];
	isp->devname = devname;

	code = 0;					// successful conclusion
	isp->done = TRUE;
	return FALSE;				// stop enumeration
	}

///////////////////////////////////////////////////////////////////////////////

BOOL MfgCallback(CInf* inf, const CString& mfgname, const CString& modelname, PVOID context, DWORD& code)
	{
	InstallStruct* isp = (InstallStruct*) context;
	isp->mfgname = mfgname;
	code = inf->EnumDevices(modelname, DeviceCallback, context);
	return code == 0 && !isp->done;
	}

///////////////////////////////////////////////////////////////////////////////

void ReportError(LPCTSTR fcn, DWORD code)
	{							// ReportError
	static struct {DWORD code; LPTSTR text;} setuperrors[] = {
		{ERROR_EXPECTED_SECTION_NAME, _T("ERROR_EXPECTED_SECTION_NAME")},
		{ERROR_BAD_SECTION_NAME_LINE, _T("ERROR_BAD_SECTION_NAME_LINE")},
		{ERROR_SECTION_NAME_TOO_LONG, _T("ERROR_SECTION_NAME_TOO_LONG")},
		{ERROR_GENERAL_SYNTAX, _T("ERROR_GENERAL_SYNTAX")},
		{ERROR_WRONG_INF_STYLE, _T("ERROR_WRONG_INF_STYLE")},
		{ERROR_SECTION_NOT_FOUND, _T("ERROR_SECTION_NOT_FOUND")},
		{ERROR_LINE_NOT_FOUND, _T("ERROR_LINE_NOT_FOUND")},
		{ERROR_NO_ASSOCIATED_CLASS, _T("ERROR_NO_ASSOCIATED_CLASS")},
		{ERROR_CLASS_MISMATCH, _T("ERROR_CLASS_MISMATCH")},
		{ERROR_DUPLICATE_FOUND, _T("ERROR_DUPLICATE_FOUND")},
		{ERROR_NO_DRIVER_SELECTED, _T("ERROR_NO_DRIVER_SELECTED")},
		{ERROR_KEY_DOES_NOT_EXIST, _T("ERROR_KEY_DOES_NOT_EXIST")},
		{ERROR_INVALID_DEVINST_NAME, _T("ERROR_INVALID_DEVINST_NAME")},
		{ERROR_INVALID_CLASS, _T("ERROR_INVALID_CLASS")},
		{ERROR_DEVINST_ALREADY_EXISTS, _T("ERROR_DEVINST_ALREADY_EXISTS")},
		{ERROR_DEVINFO_NOT_REGISTERED, _T("ERROR_DEVINFO_NOT_REGISTERED")},
		{ERROR_INVALID_REG_PROPERTY, _T("ERROR_INVALID_REG_PROPERTY")},
		{ERROR_NO_INF, _T("ERROR_NO_INF")},
		{ERROR_NO_SUCH_DEVINST, _T("ERROR_NO_SUCH_DEVINST")},
		{ERROR_CANT_LOAD_CLASS_ICON, _T("ERROR_CANT_LOAD_CLASS_ICON")},
		{ERROR_INVALID_CLASS_INSTALLER, _T("ERROR_INVALID_CLASS_INSTALLER")},
		{ERROR_DI_DO_DEFAULT, _T("ERROR_DI_DO_DEFAULT")},
		{ERROR_DI_NOFILECOPY, _T("ERROR_DI_NOFILECOPY")},
		{ERROR_INVALID_HWPROFILE, _T("ERROR_INVALID_HWPROFILE")},
		{ERROR_NO_DEVICE_SELECTED, _T("ERROR_NO_DEVICE_SELECTED")},
		{ERROR_DEVINFO_LIST_LOCKED, _T("ERROR_DEVINFO_LIST_LOCKED")},
		{ERROR_DEVINFO_DATA_LOCKED, _T("ERROR_DEVINFO_DATA_LOCKED")},
		{ERROR_DI_BAD_PATH, _T("ERROR_DI_BAD_PATH")},
		{ERROR_NO_CLASSINSTALL_PARAMS, _T("ERROR_NO_CLASSINSTALL_PARAMS")},
		{ERROR_FILEQUEUE_LOCKED, _T("ERROR_FILEQUEUE_LOCKED")},
		{ERROR_BAD_SERVICE_INSTALLSECT, _T("ERROR_BAD_SERVICE_INSTALLSECT")},
		{ERROR_NO_CLASS_DRIVER_LIST, _T("ERROR_NO_CLASS_DRIVER_LIST")},
		{ERROR_NO_ASSOCIATED_SERVICE, _T("ERROR_NO_ASSOCIATED_SERVICE")},
		{ERROR_NO_DEFAULT_DEVICE_INTERFACE, _T("ERROR_NO_DEFAULT_DEVICE_INTERFACE")},
		{ERROR_DEVICE_INTERFACE_ACTIVE, _T("ERROR_DEVICE_INTERFACE_ACTIVE")},
		{ERROR_DEVICE_INTERFACE_REMOVED, _T("ERROR_DEVICE_INTERFACE_REMOVED")},
		{ERROR_BAD_INTERFACE_INSTALLSECT, _T("ERROR_BAD_INTERFACE_INSTALLSECT")},
		{ERROR_NO_SUCH_INTERFACE_CLASS, _T("ERROR_NO_SUCH_INTERFACE_CLASS")},
		{ERROR_INVALID_REFERENCE_STRING, _T("ERROR_INVALID_REFERENCE_STRING")},
		{ERROR_INVALID_MACHINENAME, _T("ERROR_INVALID_MACHINENAME")},
		{ERROR_REMOTE_COMM_FAILURE, _T("ERROR_REMOTE_COMM_FAILURE")},
		{ERROR_MACHINE_UNAVAILABLE, _T("ERROR_MACHINE_UNAVAILABLE")},
		{ERROR_NO_CONFIGMGR_SERVICES, _T("ERROR_NO_CONFIGMGR_SERVICES")},
		{ERROR_INVALID_PROPPAGE_PROVIDER, _T("ERROR_INVALID_PROPPAGE_PROVIDER")},
		{ERROR_NO_SUCH_DEVICE_INTERFACE, _T("ERROR_NO_SUCH_DEVICE_INTERFACE")},
		{ERROR_DI_POSTPROCESSING_REQUIRED, _T("ERROR_DI_POSTPROCESSING_REQUIRED")},
		{ERROR_INVALID_COINSTALLER, _T("ERROR_INVALID_COINSTALLER")},
		{ERROR_NO_COMPAT_DRIVERS, _T("ERROR_NO_COMPAT_DRIVERS")},
		{ERROR_NO_DEVICE_ICON, _T("ERROR_NO_DEVICE_ICON")},
		{ERROR_INVALID_INF_LOGCONFIG, _T("ERROR_INVALID_INF_LOGCONFIG")},
		{ERROR_DI_DONT_INSTALL, _T("ERROR_DI_DONT_INSTALL")},
		{ERROR_INVALID_FILTER_DRIVER, _T("ERROR_INVALID_FILTER_DRIVER")},
		{ERROR_NO_DEFAULT_INTERFACE_DEVICE, _T("ERROR_NO_DEFAULT_INTERFACE_DEVICE")},
		{ERROR_INTERFACE_DEVICE_ACTIVE, _T("ERROR_INTERFACE_DEVICE_ACTIVE")},
		{ERROR_INTERFACE_DEVICE_REMOVED, _T("ERROR_INTERFACE_DEVICE_REMOVED")},
		{ERROR_NO_SUCH_INTERFACE_DEVICE, _T("ERROR_NO_SUCH_INTERFACE_DEVICE")},
		{ERROR_NOT_INSTALLED, _T("ERROR_NOT_INSTALLED")},
		};

	LPTSTR msg = NULL;
	TCHAR msgbuf[512];

	if (pprogress)
		pprogress->ShowWindow(SW_HIDE);

	if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
		NULL, code, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
		(LPTSTR) &msg, 0, NULL))

		_stprintf(msgbuf, _T("Error %d in %s: %s\n"), code, fcn, msg);
	else
		{						// not a standard message
		for (int i = 0; i < arraysize(setuperrors); ++i)
			if (setuperrors[i].code == code)
				break;
		if (i < arraysize(setuperrors))
			_stprintf(msgbuf, _T("Error %8.8lX in %s: %s\n"), code, fcn, setuperrors[i].text);
		else
			_stprintf(msgbuf, _T("Error %8.8lX in %s\n"), code, fcn);
		}						// not a standard message

	if (msg)
		LocalFree((LPVOID) msg);

	AfxMessageBox(msgbuf);
	}							// ReportError
